<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://fnoi11bfsyue.github.io</id>
    <title>Shirley Fan</title>
    <updated>2021-06-28T16:18:46.876Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://fnoi11bfsyue.github.io"/>
    <link rel="self" href="https://fnoi11bfsyue.github.io/atom.xml"/>
    <subtitle>Shirley&apos;s diary</subtitle>
    <logo>https://fnoi11bfsyue.github.io/images/avatar.png</logo>
    <icon>https://fnoi11bfsyue.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Shirley Fan</rights>
    <entry>
        <title type="html"><![CDATA[不要“脸”的论文]]></title>
        <id>https://fnoi11bfsyue.github.io/post/bu-yao-lian-de-lun-wen/</id>
        <link href="https://fnoi11bfsyue.github.io/post/bu-yao-lian-de-lun-wen/">
        </link>
        <updated>2021-06-28T15:25:15.000Z</updated>
        <content type="html"><![CDATA[<p>skin detection method</p>
<h2 id="face-beautification-and-color-enhancement-with-scene-mode-detection">Face Beautification and Color Enhancement with Scene Mode Detection</h2>
<p><a href="https://www.csie.ntu.edu.tw/~fuh/personal/FaceBeautificationandColorEnhancement.A2-1-0040.pdf">原文链接</a><br>
detect human faces<br>
Lienhart's frontal face classifier</p>
<pre><code>    Inspired by S. Bae [3], we separate an image into base layer and detail 
layer by using bilateral filter [].
我们通常把图像分成许多层。我们的增强方法的目标是在不失去和谐的情况下提高图像质量。
受S. Bae[3]的启发，我们使用双边滤波器将图像分为基层和细节层[]。
    
    The following equation (5) and (6) define the meanings of layers, where
 presents the result after Image processed bilateral filter, and presents
 fast bilateral filter algorithm [], presents the result of subtraction
 between Image and Base.
 式(5)、式(6)定义了层的含义，其中为Image经过双边滤波处理后的结果，
 为快速双边滤波算法[]，为Image与Base相减的结果
</code></pre>
<p><img src="https://fnoi11bfsyue.github.io/post-images/1624894630285.png" alt="" loading="lazy"><br>
双边滤波：这个算法是由一个高斯分量+梯度分量组成权重信息来实现模糊平滑图像的同时，保留边缘的功能的<br>
<a href="https://blog.csdn.net/Trent1985/article/details/50496969">双边滤波示意图及其来源</a><br>
<img src="https://fnoi11bfsyue.github.io/post-images/1624896856021.png" alt="" loading="lazy"><br>
</br></p>
<pre><code> Generating Skin Map:
 After setting the positions of human faces, we have to
select and modify possible skin pixels.
 The pseudo code of generating Skin Map is in Figure 5.
where Sobel is the function of applying Sobel filter on
face in x and y directions; face is the facial region of
luminance; sobel_x and sobel_y are the results after the
face applied Sobel filter in x-direction and y-direction;
th_x and th_y are the thresholds of smooth pixels; and
skin_map records the result of our skin detection method.
In our thesis, we set th_x = th_y = 15.0 by default. Figure
6. is the result after our skin detection method.  

在设置人脸的位置后，我们必须选择和修改可能的皮肤像素。
生成Skin Map的伪代码如图5所示。
其中Sobel是在人脸x、y方向上应用Sobel滤波器的函数;
面部是面部亮度区域;sobel_x和sobel_y是人脸在x方向和
y方向应用Sobel滤波器后的结果;Th_x、th_y为平滑像素的阈值;
skin_map记录了我们的皮肤检测方法的结果。
在我们的论文中，我们默认设置th_x = th_y = 15.0。数字
6. 是我们皮肤检测后的结果
</code></pre>
<p><img src="https://fnoi11bfsyue.github.io/post-images/1624896079631.png" alt="" loading="lazy"><br>
<img src="https://fnoi11bfsyue.github.io/post-images/1624896159477.png" alt="" loading="lazy"></p>
<h2 id="luminance-adapted-skin-color-modeling-for-the-robust-detection-of-skin-areas">Luminance adapted skin color modeling for the robust detection of skin areas</h2>
<p><a href="https://ieeexplore.ieee.org/document/6738540">原文链接</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[gridea code-highlight]]></title>
        <id>https://fnoi11bfsyue.github.io/post/gridea-code-highlight/</id>
        <link href="https://fnoi11bfsyue.github.io/post/gridea-code-highlight/">
        </link>
        <updated>2021-06-27T14:59:39.000Z</updated>
        <content type="html"><![CDATA[<p>#解决了自带主题simple代码无法显示高亮的问题<br>
<img src="https://fnoi11bfsyue.github.io/post-images/1624806408954.png" alt="" loading="lazy"></p>
<p>##工具<br>
highlight.js version11.0.0<br>
<a href="https://highlightjs.org/">DOWNLOAD</a></p>
<p>##步骤<br>
1.下载highlight.js，解压到\static<br>
2.修改\themes\simple\templates\post.ejs，在head中加入如下代码</p>
<pre><code class="language-JavaScript">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&lt;%= themeConfig.domain %&gt;/highlight/styles/github-dark.css&quot;&gt;
&lt;script src=&quot;&lt;%= themeConfig.domain %&gt;/highlight/highlight.pack.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode01]]></title>
        <id>https://fnoi11bfsyue.github.io/post/leetcode1/</id>
        <link href="https://fnoi11bfsyue.github.io/post/leetcode1/">
        </link>
        <updated>2021-06-27T11:08:03.000Z</updated>
        <content type="html"><![CDATA[<p>字数: 176，预计阅读时间: 1min<br>
<br></p>
<h1 id="leetcode01-两数之和">leetcode01 两数之和</h1>
<p><a href="https://leetcode-cn.com/problems/two-sum/">题目描述</a><br>
<br></p>
<h2 id="c中map">c++中map</h2>
<p><a href="https://www.cnblogs.com/fnlingnzb-learner/p/5833051.html">C++中的STL中map用法 12.基本操作函数</a></p>
<table>
<thead>
<tr>
<th style="text-align:left">映射</th>
<th style="text-align:left">底层实现</th>
<th style="text-align:left">是否有序</th>
<th style="text-align:left">数值是否可以重复</th>
<th style="text-align:left">能否更改数值</th>
<th style="text-align:left">查询效率</th>
<th style="text-align:left">增删效率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">std::map</td>
<td style="text-align:left">红黑树</td>
<td style="text-align:left">key有序</td>
<td style="text-align:left">key不可重复</td>
<td style="text-align:left">key不可修改</td>
<td style="text-align:left">O(logn)</td>
<td style="text-align:left">O(logn)</td>
</tr>
<tr>
<td style="text-align:left">std::multimap</td>
<td style="text-align:left">红黑树</td>
<td style="text-align:left">key有序</td>
<td style="text-align:left">key可重复</td>
<td style="text-align:left">key不可修改</td>
<td style="text-align:left">O(logn)</td>
<td style="text-align:left">O(logn)</td>
</tr>
<tr>
<td style="text-align:left">std::unordered_map</td>
<td style="text-align:left">哈希表</td>
<td style="text-align:left">key无序</td>
<td style="text-align:left">key不可重复</td>
<td style="text-align:left">key不可修改</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">O(1)</td>
</tr>
</tbody>
</table>
<br>
<h2 id="c中vector">c++中vector</h2>
<p><a href="vector%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">vector的使用方法</a><br>
<br></p>
<h2 id="hashmap代码">hashmap代码</h2>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        vector&lt;int&gt; answer;
        map&lt;int,int&gt; hash;
        for(int i=0; i&lt;nums.size(); ++i)hash[nums[i]]=i;//添加maphash.value
        for(int i=0; i&lt;nums.size(); ++i){
            //if((hash.count(target-nums[i]))!=0 &amp;&amp; (nums[i]*2!=target))//input[3,3] 6, output[0,1]
            if((hash.count(target-nums[i]))!=0 &amp;&amp; (i!=hash[target-nums[i]])){//count查找maphash.key是否存在，存在返回1，否则返回0
                answer.push_back(i);//vector后加一个元素
                answer.push_back(hash[target-nums[i]]);
                break;
            }
        }
        return answer;
    }
};
</code></pre>
]]></content>
    </entry>
</feed>