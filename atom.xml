<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://fnoi11bfsyue.github.io</id>
    <title>Shirley Fan</title>
    <updated>2021-07-26T08:59:09.071Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://fnoi11bfsyue.github.io"/>
    <link rel="self" href="https://fnoi11bfsyue.github.io/atom.xml"/>
    <subtitle>Shirley&apos;s diary</subtitle>
    <logo>https://fnoi11bfsyue.github.io/images/avatar.png</logo>
    <icon>https://fnoi11bfsyue.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Shirley Fan</rights>
    <entry>
        <title type="html"><![CDATA[IBM-暑期高校云计算与AI创新训练营]]></title>
        <id>https://fnoi11bfsyue.github.io/post/ibm-shu-qi-gao-xiao-yun-ji-suan-yu-ai-chuang-xin-xun-lian-ying/</id>
        <link href="https://fnoi11bfsyue.github.io/post/ibm-shu-qi-gao-xiao-yun-ji-suan-yu-ai-chuang-xin-xun-lian-ying/">
        </link>
        <updated>2021-07-26T00:59:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="人工智能的发展与创新技术-王宇新">人工智能的发展与创新技术 ——王宇新</h1>
<p>ibm watson系统：是认知计算系统的杰出代表，也是一个技术平台。认知计算代表一种全新的计算模式，它包含信息分析，自然语言处理和机器学习领域的大量技术创新，能够助力决策者从大量非结构化数据中揭示非凡的洞察。</p>
<h2 id="人工智能">人工智能</h2>
<p>which：弱，通用，强（我超强的！）<br>
roadmap：</p>
<table>
<thead>
<tr>
<th>技术</th>
<th>应用</th>
</tr>
</thead>
<tbody>
<tr>
<td>BD</td>
<td>计算智能（算力）</td>
</tr>
<tr>
<td>Understanding</td>
<td>感知技能（传感器）</td>
</tr>
<tr>
<td>Reasoning</td>
<td>认知智能（判断）</td>
</tr>
<tr>
<td>Learning</td>
<td>application</td>
</tr>
</tbody>
</table>
<br/> 
<h2 id="keyword">keyword</h2>
<p>AI&gt;ML&gt;ANN&gt;DL<br>
核心思想：让计算机程序随着数据样本积累自动获得精确的判断和归纳能力<br>
过程：training set -&gt; learning（!特征工程） -&gt; mode -&gt; 预测<br>
基本概念：feature、label、learning（mapping：特征与标签的映射关系），classification、regression（回归：连续值的预测）、clustering</p>
<h3 id="监督学习无监督学习-半监督学习">监督学习，无监督学习、半监督学习</h3>
<table>
<thead>
<tr>
<th>监督学习</th>
<th>无监督学习</th>
</tr>
</thead>
<tbody>
<tr>
<td>统计分类（离散）</td>
<td>聚类</td>
</tr>
<tr>
<td>回归分析（连续，预测效果：欠拟合、过拟合）</td>
<td>关联规则挖掘</td>
</tr>
<tr>
<td>线性回归、决策树、logic、随机森林、svm、ANN、knn、朴素贝叶斯</td>
<td>k-means</td>
</tr>
</tbody>
</table>
<p>edges -&gt; object parts（shape detectors） -&gt; object models（visual）<br>
低层信息 -&gt; 预处理 -&gt; 特征提取 -&gt; 分类识别<br>
-&gt;半监督学习</p>
<h1 id="ibm-未来已来">IBM 未来已来</h1>
<p>产业融合，技术分割 -&gt;自动化<br>
第四次工业革命：人工智能、区块链、云计算、物联网、量子计算、纳米技术、环境科学、空间科学、基因技术，众多领域的一个方向</p>
<h1 id="人工智能的基本发展方向徐啸天">人工智能的基本发展方向——徐啸天</h1>
<h2 id="人工智能的应用参考案例">人工智能的应用参考案例</h2>
<p>1.from airport to AIrport -视觉（准确度更高）<br>
passenger sercices\safty\asset management\compliance\operation...<br>
2.中国联通误停机风险分析 -电信（进行数据清洗，去冗余）<br>
3.期货指数预测、基于图像识别的零售终端市场交易 -金融<br>
4.太阳能面板质量缺陷的预测与检测 -工业<br>
5.高速自动视频检测系统 -铁路<br>
建议：打牢基础知识，核心工作领域和高技术领域对基础知识要求更高（偏微分、矩阵...）</p>
<h2 id="neural-network-examples">neural network examples</h2>
<table>
<thead>
<tr>
<th>领域</th>
<th>技术</th>
</tr>
</thead>
<tbody>
<tr>
<td>预测房价</td>
<td>数据统计或者人工智能进行分析</td>
</tr>
<tr>
<td>advertising</td>
<td>爬虫爬取进行推荐</td>
</tr>
<tr>
<td>image</td>
<td>cnn</td>
</tr>
<tr>
<td>audio speech recognition</td>
<td>rnn</td>
</tr>
<tr>
<td>radar info</td>
<td>custom ot hybrid</td>
</tr>
</tbody>
</table>
<p>structured data、unstructured data（audio image text）<br>
随着数据量的增大和机器规模的增多，网络模型呈指数增加（数据激增、算力增大、算法发展）</p>
<h3 id="神经元">神经元</h3>
<p>网易公开课 吴恩达Andrew Ng<br>
<img src="https://fnoi11bfsyue.github.io/post-images/1627281047215.png" alt="" loading="lazy"><br>
根据数据拟合出方程（即拟合出W），收敛比较快的优化算法SGD<br>
前向计算：forward i layer<br>
反向传播：backward 求偏导gradient算出当前计算结果与真实值的差异并进行缩小 lose function<br>
activation function（sigmoid、tanh、elu...激活函数）：变成[0,1]中间的数值进行输出<br>
normalizing training sets 归一化[0,1]</p>
<h3 id="cnn-图像识别">CNN -图像识别</h3>
<br/>
<h3 id="hardware">hardware</h3>
<p>FPGA,GPU：高强度乘加运算（丢给硬件去搞），丢一大坨图反复算，没有大量的load/store耗时。<br>
CPU：单块cpu服务器算力-&gt;分布式/并行-&gt;cluster/超算<br>
TPU：为了深度学习所设计的，支持半精度和单精度的浮点运算，模型里严格序列化，硬件设计时考虑数据和空间的复用<br>
（区分：gpu为了高性能计算，图像技术，单精度和双精度计算单元，deep learning用单精度浮点运算 tensor code）<br>
向量机：SVM 并行计算结果（pipeline）<br>
//单指令流多数据流SIMD<br>
搬动应用，而非数据；把数据通过分布式存储放的离应用更近一些，减少数据传输中耗时。</p>
<h3 id="框架">框架</h3>
<table>
<thead>
<tr>
<th>企业</th>
<th>框架</th>
</tr>
</thead>
<tbody>
<tr>
<td>baidu</td>
<td>paddlepaddle</td>
</tr>
<tr>
<td>-</td>
<td>pytorch</td>
</tr>
<tr>
<td>-</td>
<td>caffe2</td>
</tr>
<tr>
<td>-</td>
<td>tensoflow</td>
</tr>
</tbody>
</table>
<p>ONNX is an open-source standard for neural network models.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git]]></title>
        <id>https://fnoi11bfsyue.github.io/post/git/</id>
        <link href="https://fnoi11bfsyue.github.io/post/git/">
        </link>
        <updated>2021-07-01T07:06:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="预览">预览</h2>
<p><img src="https://fnoi11bfsyue.github.io/post-images/1625123893874.png" alt="" loading="lazy"><br>
stage(暂存区)<br>
remote(远程仓库)</p>
<h1 id="基本操作">基本操作</h1>
<h2 id="新建仓库">新建仓库</h2>
<h2 id="克隆远程仓库到本地仓库">克隆远程仓库到本地仓库</h2>
<pre><code>git clone git@github.com:fnoi11bfsyue/test.git

cd test
</code></pre>
<figure data-type="image" tabindex="1"><img src="file://D:/%E5%85%B6%E4%BB%96%E8%BD%AF%E4%BB%B6/gridea/%E5%9B%BE%E7%89%87/github-ssh.png" alt="" loading="lazy"></figure>
<h2 id="查看状态显示变更文件">查看状态，显示变更文件</h2>
<pre><code>git status 或者 git status -s   哪些更新尚未暂存，哪些更新已暂存并准备好下次提交
git diff    尚未暂存的文件更新了哪些细节
</code></pre>
<p>git文件四种状态<br>
<img src="https://fnoi11bfsyue.github.io/post-images/1625129580330.png" alt="" loading="lazy"></p>
<ol>
<li>untracked files.未跟踪文件（本地未加到暂存区的文件）</li>
<li>nothing to commit, working directory clean.没什么可提交的，工作目录干净（在最近一次提交后没有做任何改动）</li>
<li>changes not staged for commit.未为提交而暂存的更改。</li>
<li>change to be commited.更改要提交</li>
</ol>
<h2 id="添加文件到暂存区">添加文件到暂存区</h2>
<pre><code>提交变化到暂存区
git add FaceBeautificationandColorEnhancement.A2-1-0040.pdf
#git add -A     提交所有变化
git add -u     提交被修改modified的文件和被删除deleted的文件，不包括新文件new
</code></pre>
<h2 id="提交暂存区到本地仓库">提交暂存区到本地仓库</h2>
<pre><code>git commit  若没加任何路径，把要提交的文件前#去掉
esc :wq 或者 esc:q  返回上一层!

git commit -a   可以省区add，只对删除和修改文件有效

git commit -m &quot;备注&quot;
</code></pre>
<h2 id="从暂存区移除文件">从暂存区移除文件</h2>
<pre><code>git rm  FaceBeautificationandColorEnhancement.A2-1-0040.pdf
</code></pre>
<h2 id="回退版本">回退版本</h2>
<pre><code>get reset HEAD  --mixed 为默认，可以不用带该参数，用于重置暂存区的文件与上一次的提交
git reset HEAD^ hello.php  # 回退 hello.php 文件的版本到上一个版本 
HEAD~0 表示当前版本
HEAD~1 上一个版本
HEAD^2 上上一个版本
HEAD^3 上上上一个版本

git reset --hard HEAD   --hard 参数撤销工作区中所有未提交的修改内容，将暂存区与工作区都回到上一次版本，并删除之前的所有信息提交
（先对文件reset然后commit -m '修改'，无法提交成功，需要用 commit -am '修改文件'，原因执行 git reset HEAD 以取消之前 git add 添加）


(commit)保持一致，工作区文件内容保持不变
git commit --amend      重新提交，第二次提交将代替第一次提交的结果

？取消暂存的文件
？撤销对文件的修改
</code></pre>
<h2 id="移动或重命名">移动或重命名</h2>
<p>(学习网址)[https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BB%93%E5%BA%93]</p>
<h2 id="提交历史">提交历史</h2>
<pre><code>git log     查看历史commit提交记录
</code></pre>
<h2 id="查看本地仓库当前目录下文件">查看本地仓库当前目录下文件</h2>
<pre><code>ls
</code></pre>
<h1 id="远程操作">远程操作</h1>
<figure data-type="image" tabindex="2"><img src="https://fnoi11bfsyue.github.io/post-images/1625153891277.png" alt="" loading="lazy"></figure>
<h2 id="远程仓库操作">远程仓库操作</h2>
<pre><code>git remote -v   显示所有远程仓库

# 提交到 Github
$ git remote add origin git@github.com:tianqixin/runoob-git-test.git        #添加远程版本库git remote add [shortname] [url]
$ git push -u origin master
git remote rm name  # 删除远程仓库
git remote rename old_name new_name  # 修改仓库名
</code></pre>
<h2 id="远程获取代码库">远程获取代码库</h2>
<pre><code>git fetch
</code></pre>
<h2 id="下载远程代码并合并">下载远程代码并合并</h2>
<p>git pull 其实就是 git fetch 和 git merge FETCH_HEAD 的简写</p>
<pre><code>git pull
git pull origin master:brantest     将远程主机 origin 的 master 分支拉取过来，与本地的 brantest 分支合并。
git pull origin master      如果远程分支是与当前分支合并，则冒号后面的部分可以省略。
</code></pre>
<h2 id="上传远程代码并合并">上传远程代码并合并</h2>
<p>push：add——commit——push<br>
push会记录之前暂存区提交到本地仓库的时间，从GitHub可查</p>
<pre><code>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;
git push &lt;远程主机名&gt; &lt;本地分支名&gt;
git push origin master  #相当于git push origin master:master

git push origin --delete master     删除 origin 主机的 master 分支
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://fnoi11bfsyue.github.io/post-images/1625562851189.png" alt="" loading="lazy"></figure>
<pre><code>#添加README.md文件并提交

$ mkdir runoob-git-test                     # 创建测试目录
$ cd runoob-git-test/                       # 进入测试目录
$ echo &quot;# 菜鸟教程 Git 测试&quot; &gt;&gt; README.md     # 创建 README.md 文件并写入内容
$ ls                                        # 查看目录下的文件
README
$ git init                                  # 初始化
$ git add README.md                         # 添加文件
$ git commit -m &quot;添加 README.md 文件&quot;        # 提交并备注信息
[master (root-commit) 0205aab] 添加 README.md 文件
 1 file changed, 1 insertion(+)
 create mode 100644 README.md

# 提交到 Github
$ git remote add origin git@github.com:tianqixin/runoob-git-test.git
$ git push -u origin master
</code></pre>
<h3 id="tab自动补全">TAB自动补全</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[tableau]]></title>
        <id>https://fnoi11bfsyue.github.io/post/tableau/</id>
        <link href="https://fnoi11bfsyue.github.io/post/tableau/">
        </link>
        <updated>2021-06-29T12:04:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="数据分析问题">数据分析问题：</h2>
<p>明确问题：日常问题，数据量化（建立KPI）<br>
-&gt;获取数据（用户问卷调研，物联网设备，APP采集，网络爬虫）<br>
-&gt;清洗数据，呈现数据，发现异常（循环）：去重，转换，补缺，过滤/汇聚<br>
-&gt;分析数据：分析（统计sum,avg,max,min,group），挖掘，回归分类<br>
-&gt;解读数据，呈现报告：可视化，数据看板<br>
eg：优惠券的大小进行分析统计，总结出用户选择优惠范围</p>
<p>数据分析报告：日常问题，具体量化<br>
老板需求，业务目标，个人汇报，日常购物<br>
目标：决策<br>
<code>30w买一辆性价比比较高的二手奔驰车</code><br>
如何定义性价比</p>
<h2 id="获取数据">获取数据</h2>
<p><code>出场时间、购车时间、行驶公里数、汽车型号</code><br>
数据分类：内部数据（爬虫）、外部数据<br>
XPath Helper插件<br>
打开页面<br>
'''<br>
'''<br>
获取数据<br>
'''<br>
'''</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DA on Marketing Dataset]]></title>
        <id>https://fnoi11bfsyue.github.io/post/da-on-marketing-dataset/</id>
        <link href="https://fnoi11bfsyue.github.io/post/da-on-marketing-dataset/">
        </link>
        <updated>2021-06-28T23:28:40.000Z</updated>
        <content type="html"><![CDATA[<h1 id="预备知识">预备知识</h1>
<p>输出所有: data1<br>
展示某列</p>
<pre><code class="language-s=df2.name">s```
```df2[['name']]```
pandas-packge: 
计算有多少不同的name： 
```len(dg2.name.unique()) #先提取名字，在用unique提取value```
计算不同类型的小精灵有多少： 
```df2.type.value_counts() #每种不同的type分别计数```
找到所有电系的精灵
```df2[df2.type=='electric']```
![](https://fnoi11bfsyue.github.io/post-images/1624926093718.png)

&lt;/br&gt;
# targeted cmpalgns
[百度网盘链接,提取码: gdg2](https://pan.baidu.com/s/1EQrF2Sm4t1um5YmAfY6FrA)
marketing cmpalgns -&gt; targeted cmpalgns(通过数据分析判断预测，将结果为公司提供方向)
客服个人特征和通话信息记录
目的-&gt;读取数据-&gt;整合基础信息(数据)-&gt;分析
pd.read     #tab补全内容
pd.read_csv() #shift+tab功能介绍和使用方法

### merge dataset together
![](https://fnoi11bfsyue.github.io/post-images/1624927373425.png)
left-merge/inner-merge(right-merge)
outer-merge自然连接：两组数据来源有共同key

## 数据分析表
![](https://fnoi11bfsyue.github.io/post-images/1624930889210.png)</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[不要“脸”的论文]]></title>
        <id>https://fnoi11bfsyue.github.io/post/bu-yao-lian-de-lun-wen/</id>
        <link href="https://fnoi11bfsyue.github.io/post/bu-yao-lian-de-lun-wen/">
        </link>
        <updated>2021-06-28T15:25:15.000Z</updated>
        <content type="html"><![CDATA[<p>skin detection method</p>
<h2 id="face-beautification-and-color-enhancement-with-scene-mode-detection">Face Beautification and Color Enhancement with Scene Mode Detection</h2>
<p><a href="https://www.csie.ntu.edu.tw/~fuh/personal/FaceBeautificationandColorEnhancement.A2-1-0040.pdf">原文链接</a><br>
detect human faces<br>
Lienhart's frontal face classifier<br>
</br></p>
<pre><code> Generating Skin Map:
 After setting the positions of human faces, we have to
select and modify possible skin pixels.
 The pseudo code of generating Skin Map is in Figure 5.
where Sobel is the function of applying Sobel filter on
face in x and y directions; face is the facial region of
luminance; sobel_x and sobel_y are the results after the
face applied Sobel filter in x-direction and y-direction;
th_x and th_y are the thresholds of smooth pixels; and
skin_map records the result of our skin detection method.
In our thesis, we set th_x = th_y = 15.0 by default. Figure
6. is the result after our skin detection method.  

在设置人脸的位置后，我们必须选择和修改可能的皮肤像素。
生成Skin Map的伪代码如图5所示。
其中Sobel是在人脸x、y方向上应用Sobel滤波器的函数;
面部是面部亮度区域;sobel_x和sobel_y是人脸在x方向和
y方向应用Sobel滤波器后的结果;Th_x、th_y为平滑像素的阈值;
skin_map记录了我们的皮肤检测方法的结果。
在我们的论文中，我们默认设置th_x = th_y = 15.0。数字
6. 是我们皮肤检测后的结果
</code></pre>
<p><img src="https://fnoi11bfsyue.github.io/post-images/1624896079631.png" alt="" loading="lazy"><br>
<img src="https://fnoi11bfsyue.github.io/post-images/1624896159477.png" alt="" loading="lazy"><br>
</br></p>
<h4 id="双边滤波器用于修图对轮廓提取没有太大用处">双边滤波器(用于修图，对轮廓提取没有太大用处)</h4>
<p>Inspired by S. Bae [3], we separate an image into base layer and detail layer by using bilateral filter [].<br>
我们通常把图像分成许多层。我们的增强方法的目标是在不失去和谐的情况下提高图像质量。受S. Bae[3]的启发，我们使用双边滤波器将图像分为基层和细节层[]。<br>
The following equation (5) and (6) define the meanings of layers, where  presents the result after Image processed bilateral filter, and presents fast bilateral filter algorithm [], presents the result of subtraction between Image and Base.<br>
式(5)、式(6)定义了层的含义，其中为Image经过双边滤波处理后的结果， 为快速双边滤波算法[]，为Image与Base相减的结果</p>
<p><img src="https://fnoi11bfsyue.github.io/post-images/1624894630285.png" alt="" loading="lazy"><br>
双边滤波：这个算法是由一个高斯分量+梯度分量组成权重信息来实现模糊平滑图像的同时，保留边缘的功能的<br>
<img src="https://fnoi11bfsyue.github.io/post-images/1624896856021.png" alt="" loading="lazy"><br>
<a href="https://blog.csdn.net/Trent1985/article/details/50496969">双边滤波示意图及其来源</a><br>
</br></br></p>
<h2 id="luminance-adapted-skin-color-modeling-for-the-robust-detection-of-skin-areas">Luminance adapted skin color modeling for the robust detection of skin areas</h2>
<p><a href="https://ieeexplore.ieee.org/document/6738540">原文链接</a></p>
<p><a href="https://blog.csdn.net/alionsss/article/details/106980113">opencv + face_recognition —— 人脸识别案例</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[gridea code-highlight]]></title>
        <id>https://fnoi11bfsyue.github.io/post/gridea-code-highlight/</id>
        <link href="https://fnoi11bfsyue.github.io/post/gridea-code-highlight/">
        </link>
        <updated>2021-06-27T14:59:39.000Z</updated>
        <content type="html"><![CDATA[<p>#解决了自带主题simple代码无法显示高亮的问题<br>
<img src="https://fnoi11bfsyue.github.io/post-images/1624806408954.png" alt="" loading="lazy"></p>
<p>##工具<br>
highlight.js version11.0.0<br>
<a href="https://highlightjs.org/">DOWNLOAD</a></p>
<p>##步骤<br>
1.下载highlight.js，解压到\static<br>
2.修改\themes\simple\templates\post.ejs，在head中加入如下代码</p>
<pre><code class="language-JavaScript">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&lt;%= themeConfig.domain %&gt;/highlight/styles/github-dark.css&quot;&gt;
&lt;script src=&quot;&lt;%= themeConfig.domain %&gt;/highlight/highlight.pack.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode01]]></title>
        <id>https://fnoi11bfsyue.github.io/post/leetcode1/</id>
        <link href="https://fnoi11bfsyue.github.io/post/leetcode1/">
        </link>
        <updated>2021-06-27T11:08:03.000Z</updated>
        <content type="html"><![CDATA[<p>字数: 176，预计阅读时间: 1min<br>
<br></p>
<h1 id="leetcode01-两数之和">leetcode01 两数之和</h1>
<p><a href="https://leetcode-cn.com/problems/two-sum/">题目描述</a><br>
<br></p>
<h2 id="c中map">c++中map</h2>
<p><a href="https://www.cnblogs.com/fnlingnzb-learner/p/5833051.html">C++中的STL中map用法 12.基本操作函数</a></p>
<table>
<thead>
<tr>
<th style="text-align:left">映射</th>
<th style="text-align:left">底层实现</th>
<th style="text-align:left">是否有序</th>
<th style="text-align:left">数值是否可以重复</th>
<th style="text-align:left">能否更改数值</th>
<th style="text-align:left">查询效率</th>
<th style="text-align:left">增删效率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">std::map</td>
<td style="text-align:left">红黑树</td>
<td style="text-align:left">key有序</td>
<td style="text-align:left">key不可重复</td>
<td style="text-align:left">key不可修改</td>
<td style="text-align:left">O(logn)</td>
<td style="text-align:left">O(logn)</td>
</tr>
<tr>
<td style="text-align:left">std::multimap</td>
<td style="text-align:left">红黑树</td>
<td style="text-align:left">key有序</td>
<td style="text-align:left">key可重复</td>
<td style="text-align:left">key不可修改</td>
<td style="text-align:left">O(logn)</td>
<td style="text-align:left">O(logn)</td>
</tr>
<tr>
<td style="text-align:left">std::unordered_map</td>
<td style="text-align:left">哈希表</td>
<td style="text-align:left">key无序</td>
<td style="text-align:left">key不可重复</td>
<td style="text-align:left">key不可修改</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">O(1)</td>
</tr>
</tbody>
</table>
<br>
<h2 id="c中vector">c++中vector</h2>
<p><a href="vector%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">vector的使用方法</a><br>
<br></p>
<h2 id="hashmap代码">hashmap代码</h2>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        vector&lt;int&gt; answer;
        map&lt;int,int&gt; hash;
        for(int i=0; i&lt;nums.size(); ++i)hash[nums[i]]=i;//添加maphash.value
        for(int i=0; i&lt;nums.size(); ++i){
            //if((hash.count(target-nums[i]))!=0 &amp;&amp; (nums[i]*2!=target))//input[3,3] 6, output[0,1]
            if((hash.count(target-nums[i]))!=0 &amp;&amp; (i!=hash[target-nums[i]])){//count查找maphash.key是否存在，存在返回1，否则返回0
                answer.push_back(i);//vector后加一个元素
                answer.push_back(hash[target-nums[i]]);
                break;
            }
        }
        return answer;
    }
};
</code></pre>
]]></content>
    </entry>
</feed>